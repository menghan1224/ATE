package cn.edu.buaa.sei.lmf;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 * Lightweight Modeling Framework (LMF) is a standard Java library that provide
 * runtime support for object modeling. In fact, it's similar to EMF but more lightweight.
 * LMF is very small and simple.
 * <p>
 * <code>LMFContext</code> is a singleton for managing the LMF runtime context. It loads and stores the
 * meta-model, and takes the responsibility of creating instance. Before using any features provided by LMF,
 * <code>LMFContext</code> should be packed with meta-models first. In other words, client should register
 * meta-model into LMF before starting to use the other features. To do this, see {@link #load(TypeLoader)} and
 * {@link #pack()}.
 * <p>
 * The meta-model (meta-class) is presented by {@link Type} object in LMF.
 * To retrieve the information about meta-class, see {@link #typeForName(String)} and {@link #listTypes(TypeFilter)}.
 * <p>
 * The model instance is presented by {@link ManagedObject} object in LMF.
 * To create instance for a meta-class, see {@link #newInstance(Type)}.
 * <p>
 * To serialize and deserialize a group of model instances, use {@link LMFResource}.
 * <p>
 * Plus, the entire LMF is thread-safe.
 * @author Gong Zhang
 */
public final class LMFContext {
	
	public static final String DEFAULT_PACKAGE_NAME = "<default>";
	public static final String STANDARD_EXTENSION_ID = "<standard>";

	private static boolean packed = false;
	private static final Map<String, TypeBuilder> typeBuilders;
	private static final Map<String, Type> types;
	static final Map<String, Class<? extends ManagedObjectImpl>> implementationClasses;
	
	static {
		types = new HashMap<String, Type>();
		types.put(Primitives.BOOL.getName(), Primitives.BOOL);
		types.put(Primitives.INT.getName(), Primitives.INT);
		types.put(Primitives.LONG.getName(), Primitives.LONG);
		types.put(Primitives.FLOAT.getName(), Primitives.FLOAT);
		types.put(Primitives.DOUBLE.getName(), Primitives.DOUBLE);
		types.put(Primitives.STRING.getName(), Primitives.STRING);
		types.put(Primitives.LIST.getName(), Primitives.LIST);
		types.put(Primitives.ENUM.getName(), Primitives.ENUM);
		
		typeBuilders = new HashMap<String, TypeBuilder>();
		
		implementationClasses = new HashMap<String, Class<? extends ManagedObjectImpl>>();
	}
	
	/**
	 * Load and register a group of meta-classes into LMF. The <code>TypeLoader</code> object contains all the information about meta-classes.
	 * <p>
	 * The concrete <code>TypeLoader</code> can be automatically generated by LMF Meta-model Editor.
	 * Client don't need to implement or modify it.
	 * <p>
	 * This method can be only called before {@link #pack()} is called.
	 * @param typeLoader
	 */
	public static void load(TypeLoader typeLoader) {
		if (packed) throw new IllegalStateException("cannot load type since the context has already been packed.");
		Set<TypeBuilder> new_types = typeLoader.loadTypes(Collections.unmodifiableMap(typeBuilders));
		for (TypeBuilder tb : new_types) {
			if (!isValidID(tb.name, false)) throw new IllegalArgumentException(String.format("invalid type name: \"%s\"", tb.name));
			if (typeBuilders.containsKey(tb.name)) throw new IllegalArgumentException(String.format("duplicate type name: \"%s\"", tb.name));
			typeBuilders.put(tb.name, tb);
		}
		Map<String, Class<? extends ManagedObjectImpl>> new_classes = typeLoader.loadImplementationClasses();
		for (Entry<String, Class<? extends ManagedObjectImpl>> entry : new_classes.entrySet()) {
			implementationClasses.put(entry.getKey(), entry.getValue());
		}
	}
	
	/**
	 * This method is to tell LMF that all the meta-models are loaded (registered), and LMF is ready for use.
	 */
	public static void pack() {
		if (packed) throw new IllegalStateException("the managed object context has already been packed.");
		Collection<TypeBuilder> new_types = typeBuilders.values();
		
		// 1. create type
		for (TypeBuilder tb : new_types) {
			if (tb.extensionID != null && !isValidID(tb.extensionID, true)) throw new IllegalArgumentException(String.format("invalid extension id: \"%s\"", tb.extensionID));
			if (tb.packageName != null && !isValidID(tb.packageName, true)) throw new IllegalArgumentException(String.format("invalid package name: \"%s\"", tb.packageName));
			types.put(tb.name, new DynamicType(
					tb.extensionID == null ? STANDARD_EXTENSION_ID : tb.extensionID,
					tb.packageName == null ? DEFAULT_PACKAGE_NAME : tb.packageName,
					tb.name, tb.isAbstract, tb.isFinal));
		}
		
		// 2. build hierarchy
		for (TypeBuilder tb : new_types) {
			DynamicType type = (DynamicType) types.get(tb.name);
			for (String type_name : tb.superTypeNames) {
				if (types.containsKey(type_name)) {
					Type superType = types.get(type_name);
					if (!superType.isFinal()) {
						type.addSuperType(superType);
					} else {
						throw new IllegalArgumentException(String.format("can not inherit from final type: \"%s\"", superType.getName()));
					}
				} else {
					throw new IllegalArgumentException(String.format("missing super type: \"%s\"", type_name));
				}
			}
		}
		
		// 3. create attributes/enum values
		Set<String> built = new HashSet<String>(new_types.size());
		for (TypeBuilder tb : new_types) {
			loadAttributes(tb, built);
		}
		
		typeBuilders.clear();
		packed = true;
	}
	
	private static void loadAttributes(TypeBuilder tb, Set<String> built) {
		if (built.contains(tb.name)) return;
		else {
			DynamicType type = (DynamicType) types.get(tb.name);
			Map<String, Attribute> superAttributes = new HashMap<String, Attribute>();
			
			// load super type's attributes
			for (Type superType : type.getSuperTypes()) {
				loadAttributes(typeBuilders.get(superType.getName()), built);
				for (Attribute attr : superType.getAttributes()) {
					if (!superAttributes.containsKey(attr.getName())) {
						superAttributes.put(attr.getName(), attr);
					} else {
						Attribute attr2 = superAttributes.get(attr.getName());
						if (attr.getValueType() != attr2.getValueType() || attr.getValueTypeParameter() != attr2.getValueTypeParameter() || attr.isContainment() != attr2.isContainment()) {
							throw new IllegalArgumentException(String.format("conflict attribute \"%s\" on type: \"%s\"", attr.getName(), tb.name));
						}
					}
				}
			}
			
			// load new attributes
			Map<String, Attribute> newAttributes = new HashMap<String, Attribute>();
			for (AttributeBuilder ab : tb.attributes) {
				if (ab.extensionID != null && !isValidID(ab.extensionID, true)) throw new IllegalArgumentException(String.format("invalid extension id: \"%s\"", ab.extensionID));
				if (!isValidID(ab.name, false)) throw new IllegalArgumentException(String.format("invalid attribute name: \"%s\"", ab.name));
				if (newAttributes.containsKey(ab.name)) throw new IllegalArgumentException(String.format("duplicate attribute name \"%s\" on type: \"%s\"", ab.name, tb.name));
				Type valueType = types.get(ab.valueTypeName);
				if (valueType == null) throw new IllegalArgumentException(String.format("missing value type: \"%s\"", ab.valueTypeName));
				Type valueTypeParameter;
				if (ab.valueTypeParameter == null) {
					valueTypeParameter = null;
				} else {
					valueTypeParameter = types.get(ab.valueTypeParameter);
					if (valueTypeParameter == null) throw new IllegalArgumentException(String.format("missing value type parameter: \"%s\"", ab.valueTypeParameter));
				}
				if (superAttributes.containsKey(ab.name)) {
					Attribute superAttr = superAttributes.get(ab.name);
					if (valueType.isOrIsSubtypeOf(superAttr.getValueType()) &&
						ab.isContainment == superAttr.isContainment()) {
						if (superAttr.getValueTypeParameter() != null) {
							if (valueTypeParameter == null || !valueTypeParameter.isOrIsSubtypeOf(superAttr.getValueTypeParameter())) {
								throw new IllegalArgumentException(String.format("conflict attribute \"%s\" on type: \"%s\"", ab.name, tb.name));
							}
						}
						superAttributes.remove(ab.name);
					} else {
						throw new IllegalArgumentException(String.format("conflict attribute \"%s\" on type: \"%s\"", ab.name, tb.name));
					}
				}
				DynamicAttribute da = new DynamicAttribute(
						ab.extensionID == null ? STANDARD_EXTENSION_ID : ab.extensionID,
						ab.name,
						type,
						valueType,
						ab.isContainment,
						valueTypeParameter);
				newAttributes.put(ab.name, da);
			}
			
			// register attributes
			List<Attribute> attrs = new ArrayList<Attribute>(superAttributes.size() + newAttributes.size());
			for (Attribute attr : superAttributes.values()) {
				DynamicAttribute da = new DynamicAttribute(
						attr.getExtensionID(),
						attr.getName(),
						type,
						attr.getValueType(),
						attr.isContainment(),
						attr.getValueTypeParameter());
				attrs.add(da);
			}
			attrs.addAll(newAttributes.values());
			type.setAttributes(attrs);
			
			// enum values
			if (tb.enumValues != null) {
				type.setEnumValues(tb.enumValues);
			}
			
			built.add(tb.name);
		}
	}
	
	private static boolean isValidID(String id, boolean allowDot) {
		if (id == null || id.isEmpty()) return false;
		if (!Character.isLetter(id.charAt(0))) return false;
		for (int i = 1; i < id.length(); i++) {
			char ch = id.charAt(i);
			if (Character.isLetterOrDigit(ch) || ch == '_') continue;
			else if (ch == '.' && allowDot) continue;
			else return false;
		}
		return true;
	}
	
	public static boolean hasType(String name) {
		if (!packed) throw new IllegalStateException("the context has not been packed yet.");
		return types.containsKey(name);
	}
	
	/**
	 * Retrieve a <code>Type</code> by its name.
	 * @throws IllegalArgumentException if the <code>Type</code> can not be found.
	 * @param name
	 * @return
	 * @see #hasType(String)
	 */
	public static Type typeForName(String name) {
		if (!packed) throw new IllegalStateException("the context has not been packed yet.");
		Type type = types.get(name);
		if (type == null) throw new IllegalArgumentException("unknown type name: " + name);
		return type;
	}
	
	/**
	 * List <code>Type</code>s in LMF by specified <code>filter</code>. If the <code>filter</code> is <code>null</code>,
	 * this method returns all the <code>Type</code>s registered in LMF.
	 * @param filter
	 * @return
	 */
	public static List<Type> listTypes(TypeFilter filter) {
		if (!packed) throw new IllegalStateException("the context has not been packed yet.");
		List<Type> rst = new ArrayList<Type>();
		if (filter == null) {
			rst.addAll(types.values());
		} else {
			for (Entry<String, Type> entry : types.entrySet()) {
				if (filter.accept(entry.getValue())) {
					rst.add(entry.getValue());
				}
			}
		}
		return rst;
	}
	
	public static ManagedObject newInstance(String typeName) {
		Type type = typeForName(typeName);
		return newInstance(type);
	}
	
	/**
	 * Creates a new instance for specified {@link Type}.
	 * @throws IllegalArgumentException if the {@code type} is abstract.
	 * @param type the meta-class
	 * @return the model instance
	 * @see {@link #newInstance(String)}
	 */
	public static ManagedObject newInstance(Type type) {
		if (type.isPrimitiveType()) {
			if (type == Primitives.BOOL) {
				return Primitives.newInstance(false);
			} else if (type == Primitives.INT) {
				return Primitives.newInstance(0);
			} else if (type == Primitives.LONG) {
				return Primitives.newInstance(0L);
			} else if (type == Primitives.FLOAT) {
				return Primitives.newInstance(0.0f);
			} else if (type == Primitives.DOUBLE) {
				return Primitives.newInstance(0.0);
			} else if (type == Primitives.STRING) {
				return Primitives.newInstance("");
			} else if (type == Primitives.LIST) {
				return Primitives.newListInstance(Primitives.EMPTY_OBJECT_COLLECTION);
			} else if (type == Primitives.ENUM) {
				return Primitives.newEnumInstance(0);
			} else {
				throw new IllegalArgumentException(String.format("unknown primitive type: \"%s\"", type.getName()));
			}
		} else if (!type.isAbstract()) {
			Class<? extends ManagedObjectImpl> clazz = implementationClasses.get(type.getName());
			if (clazz != null) {
				try {
					return clazz.newInstance();
				} catch (InstantiationException ex) {
					throw new IllegalArgumentException(ex);
				} catch (IllegalAccessException ex) {
					throw new IllegalArgumentException(ex);
				}
			} else {
				return new ManagedObjectImpl(type);
			}
		} else {
			throw new IllegalArgumentException(String.format("can not instantiate abstract type: \"%s\"", type.getName()));
		}
	}
	
	public static Class<? extends ManagedObjectImpl> getImplementationClass(Type type) {
		return implementationClasses.get(type.getName());
	}
	
	public static Class<? extends ManagedObjectImpl> getImplementationClass(String typeName) {
		return implementationClasses.get(typeName);
	}
	
	private LMFContext() {
	}
	
}
